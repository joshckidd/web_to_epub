import os
import mimetypes
import requests
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
from ebooklib import epub

DEFAULT_CHAPTER ="""
{{content}}
"""

DEFAULT_CSS = """
BODY {color: white;}
"""

DEFAULT_SECTION = """
<h1>{{current-section}}</h1>
"""

# Extending EpubBook, because it could be helpful to access all of the values and methods of EpubBook after all of the 
# content has been generated in the initializer.
class WebBook(epub.EpubBook):

    # All content is created when a new instance of WebBook is created.
    def __init__(self, settings_dict):
        super().__init__()
        self.spine = []
        self.settings_dict = settings_dict
        self.__set_links()
        self.__set_values_order()
        self.__set_values_list()
        self.__set_ebook_values()
        self.__set_metadata()
        self.__set_templates()
        self.__set_css()
        self.__create_cover()
        if "pages" in settings_dict and "before-toc" in settings_dict["pages"]:
            self.__set_pages(settings_dict["pages"]["before-toc"])
        self.spine.append("nav")
        self.toc = []
        if "pages" in settings_dict and "before-sections" in settings_dict["pages"]:
            self.toc += self.__set_pages(settings_dict["pages"]["before-sections"])        
        self.__set_sections()
        self.add_item(epub.EpubNcx())
        self.add_item(epub.EpubNav())
        item = self.get_item_with_id("nav")
        item.add_item(self.default_css)

    # write_book should be the only public method. It writes the ebook to the file specified in the yaml file. Directly 
    # calling any other function could result in weird things happening.
    def write_book(self):
        if "file-name" in self.ebook_values:
            epub.write_epub("output/" + self.ebook_values["file-name"][0], self, {})

    # Set the values for the ebook as a whole, based on the rules provided in the yaml file.
    def __set_ebook_values(self):
        self.ebook_values = {}
        if "ebook-values" in self.settings_dict:
            values_settings = self.settings_dict["ebook-values"]
            for value in values_settings:
                new_values = []
                if "static" in values_settings[value]:
                    new_values.append(values_settings[value]["static"])
                if "aggregate" in values_settings[value]:
                    setting_split = values_settings[value]["aggregate"].split(" ", 1)
                    values = self.__get_all_values(setting_split[0])
                    if values != None:
                        new_values += self.__get_aggregate(setting_split[1], values)
                self.ebook_values[value] = new_values

    # Each link is scraped for values for an individual chapter. The values dictionary for each individual chapter is stored 
    # in the list values_list, which is generated by this method.
    def __set_values_list(self):
        self.values_list = []
        for link in self.links:
            self.values_list.append(self.__get_values(link))

    # Create a list of links to be scraped for content based on rules specified in the yaml file.
    def __set_links(self):
        self.links = []
        if "sources" in self.settings_dict:
            sources = self.settings_dict["sources"]
            if "links" in sources:
                self.links += sources["links"]
            if "link-pages" in sources:
                for link_page in sources["link-pages"]:
                    page = requests.get(link_page["url"])
                    soup = BeautifulSoup(page.content, "html.parser")
                    new_links = self.__parse_soup(soup, link_page["find"], link_page["url"])
                    absolute_links = list(map(lambda x: urljoin(link_page["url"], x), new_links))
                    self.links += absolute_links

    # Set the metadata for the ebook based on rules specified in the yaml file.
    def __set_metadata(self):
        self.default_language = ""
        if "id" in self.ebook_values:
            self.set_identifier(self.ebook_values["id"][0])
        if "title" in self.ebook_values:
            self.set_title(self.ebook_values["title"][0])
        if "language" in self.ebook_values:
            self.set_language(self.ebook_values["language"][0])
            self.default_language = self.ebook_values["language"][0]
        if "authors" in self.ebook_values:
            for author in self.ebook_values["authors"]:
                self.add_author(author)
        if "publisher" in self.ebook_values:
            self.set_unique_metadata(namespace="DC", name="publisher", value=self.ebook_values["publisher"][0])

    # Set templates to be used for the ebook based on rules specified in the yaml file.
    def __set_templates(self):
        self.page_templates = {}
        self.chapter_template = DEFAULT_CHAPTER
        self.css_template = DEFAULT_CSS
        self.section_template = DEFAULT_SECTION
        if "template-files" in self.settings_dict:
            template_files = self.settings_dict['template-files']
            for template in template_files:
                if template == "chapter":
                    with open("template/" + template_files["chapter"], "r") as f:
                        self.chapter_template = f.read()
                elif template == "css":
                    with open("template/" + template_files["css"], "r") as f:
                        self.css_template = f.read()
                elif template == "section":
                    with open("template/" + template_files["section"], "r") as f:
                        self.section_template = f.read()
                else:
                    with open("template/" + template_files[template], "r") as f:
                        self.page_templates[template] = f.read()


    # Create chapters for the ebook based on the chapter template and the values dictionary for the chapter. Optionally 
    # specify a section to create the chapters for. Return a list of the chapters created.
    def __create_chapters(self, section=None):
        chapter_list = []
        for values in self.values_list:
            if section == None or section in values[self.ebook_values["section-value"][0]]:
                title = ""
                if "chapter-title" in self.ebook_values and self.ebook_values["chapter-title"][0] in values:
                    title = values[self.ebook_values["chapter-title"][0]][0]
                c1 = epub.EpubHtml(title=title, file_name=title + ".xhtml", lang=self.default_language, )
                c1.content = self.__merge_content(self.chapter_template, values)
                c1.add_item(self.default_css)
                self.add_item(c1)
                chapter_list.append(c1)
        return chapter_list

    # Create a values dictionary based on a specified url and rules specified in the yaml file.
    def __get_values(self, url):
        values = {}
        if "values" in self.settings_dict:
            values_settings = self.settings_dict["values"]
            page = requests.get(url)
            soup = BeautifulSoup(page.content, "html.parser")
            for value in self.values_order:
                new_values = []
                if "static" in values_settings[value]:
                    new_values.append(values_settings[value]["static"])
                if "find" in values_settings[value]:
                    new_values += self.__parse_soup(soup, values_settings[value]["find"], url)
                if "remove" in values_settings[value]:
                    new_values = list(map(lambda x: self.__remove_tags(x, values_settings[value]["remove"]), new_values))
                if "aggregate" in values_settings[value]:
                    setting_split = values_settings[value]["aggregate"].split(" ", 1)
                    if setting_split[0] in values:
                        new_values += self.__get_aggregate(setting_split[1], values[setting_split[0]])
                if "template" in values_settings[value]:
                    new_values.append(self.__merge_content(values_settings[value]["template"], values))
                values[value] = new_values                
            return values

    # Scrape and create images that are needed for specific content.
    def __get_images(self, soup, url):
        images = soup.find_all("img")
        for image in images:
            source = image["src"]
            name = os.path.basename(urlparse(source).path)
            absolute_link = urljoin(url, source)
            image_content = requests.get(absolute_link).content
            mime_type, encoding = mimetypes.guess_type(name)
            img = epub.EpubImage(
                uid="image_" + name,
                file_name="static/" + name,
                media_type=mime_type,
                content=image_content,
            )
            self.add_item(img)
            image["src"] = "static/" + name
        return str(soup)

    # Used for aggregate rules.
    def __get_aggregate(self, rule, values):
        rule_split = rule.split(" ", 1)
        if rule_split[0] == "join":
            if rule_split[1][0] == '"' and rule_split[1][-1] == '"':
                joiner = rule_split[1][1:-1]
            else:
                joiner = rule_split[1]
            return [joiner.join(values)]
        if rule_split[0] == "list":
            return values

    # Used for ebook level aggregations, when a list of all values from each chapter is desired.        
    def __get_all_values(self, value):
        all_values = []
        for values in self.values_list:
            all_values += values[value]
        return all_values

    # Find specific data based on a series of searches specified by rules in the yaml file.
    def __parse_soup(self, soup, find, url):
        find_split = find.split(" ", 1)
        results = self.__find_by_rule(soup, find_split[0])
        if len(find_split) == 1:
            for result in results:
                result = self.__get_images(result, url)
            return list(map(lambda x: str(x), results))
        elif find_split[1] == "text":
            return list(map(lambda x: x.get_text(), results))
        elif find_split[1][0:5] == "attr=":
            split_attr = find_split[1].split("=")
            return list(map(lambda x: x.attrs[split_attr[1]], results))
        new_results = []
        for result in results:
            new_results += self.__parse_soup(result, find_split[1], url)
        return new_results

    # Used to remove content from scraped values.
    def __remove_tags(self, content, tag_list):
        soup = BeautifulSoup(content, "html.parser")
        for tag in tag_list:
            remove_list = self.__find_by_rule(soup, tag)
            if len(remove_list) != 0:
                for remove in remove_list:
                    remove.decompose()
        return str(soup)

    # Used to search scraped content.
    def __find_by_rule(self, soup, rule):
        if "." in rule:
            find_args = rule.split(".")
            results = soup.find_all(find_args[0], class_=find_args[1])
        elif "#" in rule:
            find_args = rule.split("#")
            results = soup.find_all(find_args[0], id=find_args[1])
        else:
            results = soup.find_all(rule)
        return results
    
    # Merges values into templates.
    def __merge_content(self, template, values):
        content = template
        merge_fields = re.findall("{{([^}]*)}}", template)
        for merge_field in merge_fields:
            if merge_field in values:
                content = content.replace("{{" + merge_field + "}}", values[merge_field][0])
        return content

    # Template and aggregate rules depend on other values. This function orders the values so that dependencies are
    # calculated before the values that depend on them.
    def __set_values_order(self):
        self.values_order = []
        if "values" in self.settings_dict:
            values = self.settings_dict["values"]
            current_length = -1
            while current_length < len(self.values_order):
                current_length = len(self.values_order)
                for value in values:
                    if value not in self.values_order:
                        if "aggregate" not in values[value] and "template" not in values[value]:
                            self.values_order.append(value)
                        else:
                            dependencies = set()
                            if "aggregate" in values[value]:
                                dependencies.add(values[value]["aggregate"].split(" ", 1)[0])
                            if "template" in values[value]:
                                dependencies.update(re.findall("{{([^}]*)}}", values[value]["template"]))
                            met_dependencies = set()
                            for dependency in dependencies:
                                if dependency in self.values_order:
                                    met_dependencies.add(dependency)
                            if len(dependencies) == len(met_dependencies):
                                self.values_order.append(value)
            if len(self.values_order) < len(values):
                for value in values:
                    if value not in self.values_order:
                        self.values_order.append(value)

    # Set the css file to the one specified in the yaml file.
    def __set_css(self):
        self.default_css = epub.EpubItem(
            uid="css_css1",
            file_name="styles.css",
            media_type="text/css",
            content=self.css_template,
        )
        self.add_item(self.default_css)

    # Create the sections for the ebook. Or just create chapters for the ebook if no sections are specified in the yaml file.
    def __set_sections(self):
        if "sections" in self.ebook_values and "section-value" in self.ebook_values:
            for section in self.ebook_values["sections"][0]:
                id_name = section.lower().replace(" ", "-")
                self.ebook_values["current-section"] = [section]
                clist = self.__create_chapters(section=section)
                if len(clist) > 0:
                    s1page = epub.EpubHtml(uid=id_name, file_name=id_name + ".xhtml", content=self.__merge_content(self.section_template, self.ebook_values), title=section)
                    s1page.add_item(self.default_css)
                    self.add_item(s1page)
                    self.spine.append(s1page)
                    s1 = epub.Section(section, href=id_name + ".xhtml")
                    self.spine += clist
                    self.toc.append([s1, clist])
        else:
            clist = self.__create_chapters()
            self.toc += clist
            self.spine += clist

    # Create pages based on page templates and the ebook values.
    def __set_pages(self, pages):
        toc_list = []
        for page in pages:
            if "name" in page and "template" in page and page["template"] in self.page_templates:
                id_name = page["name"].lower().replace(" ", "-")
                p1 = epub.EpubHtml(uid=id_name, file_name=id_name + ".xhtml", content=self.__merge_content(self.page_templates[page["template"]], self.ebook_values), title=page["name"])
                p1.add_item(self.default_css)
                self.add_item(p1)
                self.spine.append(p1)
                toc_list.append(p1)
        return toc_list
    
    # Create the cover. Set it to be linear so that it can appear first in the ebook.
    def __create_cover(self):
        if "cover" in self.ebook_values:
            with open("template/" + self.ebook_values["cover"][0], "rb") as f:
                image_content = f.read()
            self.set_cover(content=image_content, file_name="static/" + self.ebook_values["cover"][0])
            self.get_item_with_id("cover").is_linear = True
            self.spine.append("cover")